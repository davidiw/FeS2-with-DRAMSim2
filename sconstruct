# top-level scons build file

import glob, os, re
from FeS2.global_variables import *

protocol = 'MOESI_DRAM_directory'
#protocol = 'MOESI_directory'

includes = ['.', 'common', 'decoder', 'tools/include', 'autogen/include',
            'pyrite', SIMICS_SYMLINK + '/src/include', 'generated/' + protocol, 'common/gzstream', 
            'ruby/buffers', 'ruby/common', 'ruby/eventqueue', 'ruby/system', 
	    'ruby/network', 'ruby/network/simple', 'ruby/mmpredictors', 'ruby/recorder', 'ruby/tester', 'ruby/profiler',
            'external/inst_record', 'DRAMSim2']

library_paths = ['.', 'DRAMSim2']
libraries = ['z']

env = Environment( CPPPATH=includes,
		   LIBS=libraries, LIBPATH=library_paths,
                   PATH=os.environ['PATH'],
                   CCFLAGS='-fpic -msse -msse2',
                   LD_LIBRARY_PATH=os.getenv('LD_LIBRARY_PATH','') )

if int(ARGUMENTS.get('debug', 0)):
    env.Append(CCFLAGS=' -O0 -g -DRUBY_DEBUG=true')
else:
    env.Append(CCFLAGS=' -O3 -DRUBY_DEBUG=false')

if int(ARGUMENTS.get('host32', 0)):
    env.Append(CCFLAGS=' -m32')
    env.Append(LINKFLAGS=' -m32')

# TODO: this doesn't seem to do anything, so we end up .o files polluting source directories
#env.BuildDir('build', 'decoder')

# custom builders
spasm = Builder(action = 'tools/bin/spasm.py $SOURCE > $TARGET',
                suffix = '.cpp.h',
                src_suffix = '.spasm')
env.Append(BUILDERS = {'Spasm' : spasm})

cxxunit = Builder(action = 'tools/bin/cxxtestgen.py --error-printer -o $TARGET $SOURCE',
                  suffix = '.cpp',
                  src_suffix = '.cpp.h')
env.Append(BUILDERS = {'Cxxunit' : cxxunit})

cpreprocessor = Builder(action = 'cpp -P -Iautogen/include $SOURCE $TARGET',
                        suffix = '.py',
                        src_suffix = '.py.skel')
env.Append(BUILDERS = {'CPreProcessor' : cpreprocessor})

def autogeneratedFiles(target, source, env):
    """Informs scons of the files autogenerated from some .def file
(via a call to 'gendef.py --deps'). Also adds gendef.py as a source
dependence for those autogenerated files."""
    assert len(source) == 1, "gendef.py called with multiple .def files???"
    
    output = os.popen( 'python gendef.py --deps ' + str(source[0]), 'r' )
    files = output.readlines()
    output.close()
    realTargets = []
    for f in files:
        realTargets.append( f.strip() )

    source.append( "gendef.py" )
        
    return realTargets, source
# TODO: separate out the creation of the autogen directory tree into some vanilla 'init' target    
autogenFromDef = Builder( action='mkdir -p autogen/include autogen/src && python gendef.py --output-dir-root autogen $SOURCE',
                          #src_suffix='.dep',
                          emitter=autogeneratedFiles )
env.Append( BUILDERS = {'Def' : autogenFromDef} )

# ACTUALLY BUILD THE CODE


# NB: scons doesn't inherit from the shell environment
env['ENV']['PYTHONPATH'] = os.environ['PYTHONPATH']

decoderSources = glob.glob( os.path.join("decoder","*.cpp") )
pyriteSources  = glob.glob( os.path.join("pyrite","*.cpp") )
commonSources  = glob.glob( os.path.join("common","*.cpp") ) + \
		 glob.glob( os.path.join("common","*.C") ) + \
		 glob.glob( os.path.join("common/gzstream","*.cpp") )
#systemSources = glob.glob( os.path.join("system","*.cpp") )
rubySources    = glob.glob( os.path.join("ruby/buffers","*.C") ) + \
		 glob.glob( os.path.join("ruby/common","*.C") ) + \
		 glob.glob( os.path.join("ruby/eventqueue","*.C") ) + \
		 glob.glob( os.path.join("ruby/network","*.C") ) + \
		 glob.glob( os.path.join("ruby/network/simple","*.C") ) + \
		 glob.glob( os.path.join("ruby/profiler","*.C") ) + \
		 glob.glob( os.path.join("ruby/recorder","*.C") ) + \
		 glob.glob( os.path.join("ruby/system","*.C") ) + \
		 glob.glob( os.path.join("DRAMSim2","*.cpp") ) 
rubyTestSources= glob.glob( os.path.join("ruby/tester","*.C") ) 
traceDumpSources=glob.glob( os.path.join("external/inst_record","*.cpp") )
sliccSources   = glob.glob( os.path.join("slicc/ast", "*.C") ) + \
                 glob.glob( os.path.join("slicc", "*.C") ) + \
                 glob.glob( os.path.join("slicc/symbols", "*.C") ) + \
                 glob.glob( os.path.join("slicc/generator", "*.C") )
protocolSources = glob.glob( os.path.join("generated/" + protocol, "*.C") )

# build the autogenerated code
autogenSources  = env.Def( 'def/debug_cat.def' )
autogenSources += env.Def( 'def/stats.def' )
autogenSources += env.Def( 'def/params.def' )

autogenSources = [ a for a in autogenSources if (str(a).endswith('.cpp') or
                                                 str(a).endswith('.c'))]

# build slicc
sliccEnv = Environment( CPPPATH= ['slicc', 'slicc/ast', 'common', 'slicc/symbols', 'slicc/generator', 'generated/' + protocol],
                        YACCFLAGS= '-d', CC = 'g++',
                        CCFLAGS='-msse -msse2 -O3 -DRUBY_DEBUG=false',
                        PATH=os.environ['PATH'],
                        LD_LIBRARY_PATH=os.getenv('LD_LIBRARY_PATH','') )

sliccEnv.Append()

if int(ARGUMENTS.get('host32', 0)):
    sliccEnv.Append(CCFLAGS=' -m32')
    sliccEnv.Append(LINKFLAGS=' -m32')

sliccParserFiles = sliccEnv.CFile(target = 'slicc/parser/parser.c', source = 'slicc/parser/parser.y')
sliccLexer = sliccEnv.CFile(target = 'slicc/parser/lexer.c', source = 'slicc/parser/lexer.l')
sliccUtil = sliccEnv.StaticObject(target = 'slicc/util.o', source = 'common/util.C')
sliccExec = 'tools/bin/slicc.exec'
sliccProgram = sliccEnv.Program(target = sliccExec, source = sliccSources + ['slicc/parser/parser.c'] + sliccLexer + sliccUtil)

def protocolSMFiles():
    output = os.popen( 'cat protocols/' + protocol + '.slicc',  'r' )
    outputLines = output.readlines()
    sourceFiles = []
    for line in outputLines:
        sourceFiles.append('protocols/' + os.path.basename(line.rstrip('\n')))
    return sourceFiles
protocolSMs = ['protocols/external.sm', 'protocols/parameters.sm']
protocolSMs += protocolSMFiles()

if not os.path.exists('generated/' + protocol + '/html'):
    Execute(Mkdir('generated/' + protocol + '/html'))

def sliccEmitter(target, source, env):
    env.Depends(target, sliccProgram)
    return (target, source)
sliccBuilder = Builder( action='./' + sliccExec + ' generated/' + protocol + ' generated/' + protocol + '/html ' + protocol + ' $SOURCES',
                        emitter=sliccEmitter)
env.Append( BUILDERS = {'slicc' : sliccBuilder} )
sliccDummy = env.slicc('#slicc-dummy', protocolSMs)
env.Clean(sliccDummy, 'generated/' + protocol)

# This builds the protocol sources if they were just generated
def buildProtocolObj(target, source, env):
    protocolSources = glob.glob( os.path.join("generated/" + protocol, "*.C") )
    protocolObj = env.Object(protocolSources)
    env.Install('obj', protocolObj)
    # Update the TopLevelAlias so that scons re-evaluates dependences
    env.Alias('TopLevelAlias', protocolObj)
    return None
protocolObjBuilder = Builder(action = buildProtocolObj)
env.Append( BUILDERS = {'protocolObj' : protocolObjBuilder} )
protocolDummy = env.protocolObj('#protocol-dummy', sliccDummy)

# This builds the protocol sources if they already exist
protocolSources = glob.glob( os.path.join("generated/" + protocol, "*.C") )
protocolObj = env.Object(protocolSources)
env.Install('obj', protocolObj)

# build object files for simics makefile
obj = env.Object(decoderSources + autogenSources + pyriteSources + commonSources + rubySources + rubyTestSources + traceDumpSources)
env.Depends(obj, sliccDummy)
env.Install('obj', obj)

env.CPreProcessor( 'pyrite/commands' )

# build the tester
env.Spasm( 'decoder/test/driver' )
env.Cxxunit( 'decoder/test/driver' )
testDecoder = env.Program( 'decoder-test',
                           ["decoder/test/driver.cpp"] + decoderSources )
env.Install( 'test', testDecoder )

