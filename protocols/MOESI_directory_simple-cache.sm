/* This file is part of SLICC (Specification Language for Implementing
   Cache Coherence), a component of the Multifacet GEMS (General
   Execution-driven Multiprocessor Simulator) software toolset
   originally developed at the University of Wisconsin-Madison.

   SLICC was originally developed by Milo Martin with substantial
   contributions from Daniel Sorin.

   Ruby was originally developed primarily by Milo Martin and Daniel
   Sorin with contributions from Ross Dickson, Carl Mauer, and Manoj
   Plakal.

   Substantial further development of Multifacet GEMS at the
   University of Wisconsin was performed by Alaa Alameldeen, Brad
   Beckmann, Ross Dickson, Pacia Harper, Milo Martin, Michael Marty,
   Carl Mauer, Kevin Moore, Manoj Plakal, Daniel Sorin, Min Xu, and
   Luke Yen.

   Additional development was performed at the University of
   Pennsylvania by Milo Martin.

   --------------------------------------------------------------------

   Copyright (C) 1999-2005 by Mark D. Hill and David A. Wood for the
   Wisconsin Multifacet Project.  Contact: gems@cs.wisc.edu
   http://www.cs.wisc.edu/gems/

   This file is based upon a pre-release version of Multifacet GEMS
   from 2004 and may also contain additional modifications and code
   Copyright (C) 2004-2007 by Milo Martin for the Penn Architecture
   and Compilers Group.  Contact: acg@lists.seas.upenn.edu
   http://www.cis.upenn.edu/acg/

   --------------------------------------------------------------------

   Multifacet GEMS is free software; you can redistribute it and/or
   modify it under the terms of version 2 of the GNU General Public
   License as published by the Free Software Foundation.  This 
   software comes with ABSOLUTELY NO WARRANTY.  For details see the 
   file LICENSE included with the distribution.
*/
// -----------------------------------------------------------------------------
//
//  This file is part of FeS2.
//
//  FeS2 is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  FeS2 is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with FeS2.  If not, see <http://www.gnu.org/licenses/>.
//
// -----------------------------------------------------------------------------

machine(L1Cache, "Directory protocol") {

  // STATES
  enumeration(State, desc="Cache states", default="L1Cache_State_I") {
    // Base states
    NP, desc="Not Present";
    I, desc="Idle";
    S, desc="Shared";
    O_C, "O^C", desc="Owned (clean)";
    O_D, "O^D", desc="Owned (dirty)";
    E, desc="Exclusive (clean)";
    M, desc="Modified (dirty)";
    MM, desc="Modified (dirty and locally modified)";

    // Transient States
    IM, "IM", desc="Issued GetX";
    SM, "SM", desc="Issued GetX, we still have an old copy of the line";
    OM, "OM", desc="Issued GetX, received data";
    IS, "IS", desc="Issued GetS";
    II, "II", desc="Issued Put, waiting for ack, nack, or forwarded request";
  }

  // EVENTS
  enumeration(Event, desc="Cache events") {
    Load,            desc="Load request from the processor";
    Ifetch,          desc="I-fetch request from the processor";
    Store,           desc="Store request from the processor";
    L2_Replacement,  desc="Replacement";

    // Requests
    Own_GETX,      desc="We observe our own GetX forwarded back to us";
    Fwd_GETX,      desc="A GetX from another processor";
    Fwd_GETS,      desc="A GetS from another processor";
    Inv,           desc="Invalidations from the directory";

    // Responses
    Ack,             desc="Received an ack message";
    Data,            desc="Received a data message, responder has a shared copy";
    Exclusive_Data_Clean,  desc="Received a data message, no other processor has it, data is clean";
    Exclusive_Data_Dirty,  desc="Received a data message, no other processor has it, data is dirty";

    Writeback_Ack,   desc="Writeback completion";

    // Triggers
    All_acks,                  desc="Received all required data and message acks";
  }

  // TYPES

  // CacheEntry
  structure(Entry, interface="CacheEntryBase", desc="...") {
    Address Address,         desc="Address of this block, required by CacheMemory";
    Time LastRef,            desc="Last time this block was referenced, required by CacheMemory";
    AccessPermission Permission, desc="Access permission for this block, required by CacheMemory"; 
    DataBlock DataBlk,       desc="data for the block, required by CacheMemory";
    State CacheState,        desc="cache state";
    int NumPendingMsgs, default="0",     desc="Number of acks/data messages that this processor is waiting for";
  }

  external_type(CacheMemory) {
    bool cacheAvail(Address);
    Address cacheProbe(Address);
    void allocate(Address);
    void deallocate(Address);
    Entry lookup(Address), cast_hack="yes";
    void changePermission(Address, AccessPermission);
    bool isTagPresent(Address);
  }

  CacheMemory cacheMemory, constructor_hack='L1Cache_Entry(),g_param_ptr->L2_CACHE_NUM_SETS_BITS(),g_param_ptr->L2_CACHE_ASSOC(),"L2"';

  void changePermission(Address addr, AccessPermission permission) {
    cacheMemory.changePermission(addr, permission);
  }

  State getState(Address addr) {

    if (cacheMemory.isTagPresent(addr)) {
      return cacheMemory[addr].CacheState;
    }
    return State:NP;
  }

  void setState(Address addr, State state) {
    if (cacheMemory.isTagPresent(addr)) {
      cacheMemory[addr].CacheState := state;

      if (state == State:MM) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:M) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:E) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:O_C) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:O_D) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:S) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:I) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:II) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      } else if (state == State:IS) {
        assert(cacheMemory[addr].NumPendingMsgs == 0);
      }

      // Set permission
      if (state == State:MM) {
        changePermission(addr, AccessPermission:Read_Write);
      } else if ((state == State:S) || 
                 (state == State:O_C) || 
                 (state == State:O_D) || 
                 (state == State:M) || 
                 (state == State:E) || 
                 (state == State:SM) || 
                 (state == State:OM)) {
        changePermission(addr, AccessPermission:Read_Only);
      } else {
        changePermission(addr, AccessPermission:Invalid);
      }
    }
  }

  // ** BUFFERS **

  MessageBuffer requestFromCache, network="To", virtual_network="0", ordered="false";
  MessageBuffer forwardToCache, network="From", virtual_network="1", ordered="false";
  MessageBuffer responseFromCache, network="To", virtual_network="2", ordered="false";
  MessageBuffer responseToCache, network="From", virtual_network="2", ordered="false";
  MessageBuffer unblockFromCache, network="To", virtual_network="3", ordered="false";
  MessageBuffer triggerQueue, ordered="true";
  MessageBuffer requestQueue, ordered="false";

  // ** OUT_PORTS **

  out_port(requestNetwork_out, RequestMsg, requestFromCache);
  out_port(responseNetwork_out, ResponseMsg, responseFromCache);
  out_port(unblockNetwork_out, ResponseMsg, unblockFromCache);
  out_port(triggerQueue_out, TriggerMsg, triggerQueue);

  // ** IN_PORTS **

  // Trigger Queue
  in_port(triggerQueue_in, TriggerMsg, triggerQueue) {
    if (triggerQueue_in.isReady()) {
      peek(triggerQueue_in, TriggerMsg) {
        if (in_msg.Type == TriggerType:ALL_ACKS) {
          trigger(Event:All_acks, in_msg.Address);
        } else {
          error("Unexpected message");
        }
      }
    }
  }

  // Nothing from the request network

  // Forward Network
  in_port(forwardToCache_in, RequestMsg, forwardToCache) {
    if (forwardToCache_in.isReady()) {
      peek(forwardToCache_in, RequestMsg) {
        if (in_msg.Type == CoherenceRequestType:GETX) {
          if (in_msg.Requestor == id) {
            trigger(Event:Own_GETX, in_msg.Address);
          } else {
            trigger(Event:Fwd_GETX, in_msg.Address);
          }
        } else if (in_msg.Type == CoherenceRequestType:GETS) {
          trigger(Event:Fwd_GETS, in_msg.Address);
        } else if (in_msg.Type == CoherenceRequestType:INV) {
          trigger(Event:Inv, in_msg.Address);
        } else {
          error("Unexpected message");
        }
      }
    }
  }

  // Response Network
  in_port(responseToCache_in, ResponseMsg, responseToCache) {
    if (responseToCache_in.isReady()) {
      peek(responseToCache_in, ResponseMsg) {
        if (in_msg.Type == CoherenceResponseType:ACK) {
          trigger(Event:Ack, in_msg.Address);
        } else if (in_msg.Type == CoherenceResponseType:DATA) {
          trigger(Event:Data, in_msg.Address);
        } else if (in_msg.Type == CoherenceResponseType:DATA_EXCLUSIVE_CLEAN) {
          trigger(Event:Exclusive_Data_Clean, in_msg.Address);
        } else if (in_msg.Type == CoherenceResponseType:DATA_EXCLUSIVE_DIRTY) {
          trigger(Event:Exclusive_Data_Dirty, in_msg.Address);
        } else if (in_msg.Type == CoherenceResponseType:WB_ACK) {
          trigger(Event:Writeback_Ack, in_msg.Address);
        } else {
          error("Unexpected message");
        }
      }
    }
  }

  // Nothing from the unblock network

  // Mandatory Queue
  in_port(mandatoryQueue_in, CacheMsg, requestQueue, desc="...") {
    if (mandatoryQueue_in.isReady()) {
      peek(mandatoryQueue_in, CacheMsg) {
        if (cacheMemory.cacheAvail(in_msg.Address) == false) {
          trigger(Event:L2_Replacement, cacheMemory.cacheProbe(in_msg.Address));
        } else {
          if (in_msg.Type == CacheRequestType:LD) {
            trigger(Event:Load, in_msg.Address);
          } else if (in_msg.Type == CacheRequestType:IFETCH) {
            trigger(Event:Ifetch, in_msg.Address);
          } else if ((in_msg.Type == CacheRequestType:ST) || (in_msg.Type == CacheRequestType:ATOMIC)) {
            trigger(Event:Store, in_msg.Address);
          } else {
            error("Invalid CacheRequestType");
          }
        }
      } 
    }
  }
  
  // ACTIONS

  action(a_issueGETS, "a", desc="Issue GETS") {
    enqueue(requestNetwork_out, RequestMsg, ISSUE_LATENCY) {
      out_msg.Address := address;
      out_msg.Type := CoherenceRequestType:GETS;
      out_msg.Requestor := id;
      out_msg.Destination.add(MachineType:Directory, map_address_to_node(address));
      out_msg.MessageSize := MessageSizeType:Request_Control;
    }
  }

  action(b_issueGETX, "b", desc="Issue GETX") {
    enqueue(requestNetwork_out, RequestMsg, ISSUE_LATENCY-1) {
      out_msg.Address := address;
      out_msg.Type := CoherenceRequestType:GETX;
      out_msg.Requestor := id;
      out_msg.Destination.add(MachineType:Directory, map_address_to_node(address));
      out_msg.MessageSize := MessageSizeType:Request_Control;
    }
  }

  action(d_issueCleanPUT, "d", desc="Issue Clean PUT") {
    enqueue(requestNetwork_out, RequestMsg, CACHE_LATENCY) {
      out_msg.Address := address;
      out_msg.Type := CoherenceRequestType:PUT_CLEAN;
      out_msg.Requestor := id;
      out_msg.Destination.add(MachineType:Directory, map_address_to_node(address));
      // NOTE: in a real system this would not send data.  We send
      // data here only so we can check it at the memory
      out_msg.DataBlk := cacheMemory[address].DataBlk;
      out_msg.MessageSize := MessageSizeType:Writeback_Control;
    }
  }

  action(dd_issueDirtyPUT, "\d", desc="Issue Dirty PUT") {
    enqueue(requestNetwork_out, RequestMsg, CACHE_LATENCY) {
      out_msg.Address := address;
      out_msg.Type := CoherenceRequestType:PUT_DIRTY;
      out_msg.Requestor := id;
      out_msg.Destination.add(MachineType:Directory, map_address_to_node(address));
      out_msg.DataBlk := cacheMemory[address].DataBlk;
      out_msg.MessageSize := MessageSizeType:Writeback_Data;
    }
  }

  action(e_sendData, "e", desc="Send data from cache to requestor") {
    peek(forwardToCache_in, RequestMsg) {
      enqueue(responseNetwork_out, ResponseMsg, CACHE_LATENCY) {
        out_msg.Address := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.Sender := id;
        out_msg.Destination.add(MachineType:L1Cache, in_msg.Requestor);
        out_msg.DataBlk := cacheMemory[address].DataBlk;
        out_msg.Acks := in_msg.Acks;
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }
  }

  action(ee_sendDataExclusive, "\e", desc="Send data from cache to requestor, don't keep a shared copy") {
    peek(forwardToCache_in, RequestMsg) {
      enqueue(responseNetwork_out, ResponseMsg, CACHE_LATENCY) {
        out_msg.Address := address;
        out_msg.Type := CoherenceResponseType:DATA_EXCLUSIVE_DIRTY;
        out_msg.Sender := id;
        out_msg.Destination.add(MachineType:L1Cache, in_msg.Requestor);
        out_msg.DataBlk := cacheMemory[address].DataBlk;
        out_msg.Acks := in_msg.Acks;
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }
  }
  
  action(f_sendAck, "f", desc="Send ack from cache to requestor") {
    peek(forwardToCache_in, RequestMsg) {
      enqueue(responseNetwork_out, ResponseMsg, CACHE_LATENCY) {
        out_msg.Address := address;
        out_msg.Type := CoherenceResponseType:ACK;
        out_msg.Sender := id;
        out_msg.Destination.add(MachineType:L1Cache, in_msg.Requestor);
        out_msg.Acks := 0 - 1; // -1
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(g_sendUnblock, "g", desc="Send unblock to memory") {
    enqueue(unblockNetwork_out, ResponseMsg, NULL_LATENCY) {
      out_msg.Address := address;
      out_msg.Type := CoherenceResponseType:UNBLOCK;
      out_msg.Sender := id;
      out_msg.Destination.add(MachineType:Directory, map_address_to_node(address));
      out_msg.MessageSize := MessageSizeType:Unblock_Control;
    }
  }

  action(gg_sendUnblockExclusive, "\g", desc="Send unblock exclusive to memory") {
    enqueue(unblockNetwork_out, ResponseMsg, NULL_LATENCY) {
      out_msg.Address := address;
      out_msg.Type := CoherenceResponseType:UNBLOCK_EXCLUSIVE;
      out_msg.Sender := id;
      out_msg.Destination.add(MachineType:Directory, map_address_to_node(address));
      out_msg.MessageSize := MessageSizeType:Unblock_Control;
    }
  }

  action(h_load_hit, "h", desc="Notify sequencer the load completed.") {
    DEBUG_EXPR(cacheMemory[address].DataBlk);
    get_sequencer(id).readCallback(address, cacheMemory[address].DataBlk);
  }

  action(hh_store_hit, "\h", desc="Notify sequencer that store completed.") {
    DEBUG_EXPR(cacheMemory[address].DataBlk);
    get_sequencer(id).writeCallback(address, cacheMemory[address].DataBlk);
  }

  action(j_popTriggerQueue, "j", desc="Pop trigger queue.") {
    triggerQueue_in.dequeue();
  }

  action(k_popMandatoryQueue, "k", desc="Pop mandatory queue.") {
    mandatoryQueue_in.dequeue();
  }
  
  action(l_popForwardQueue, "l", desc="Pop forwareded request queue.") {
    forwardToCache_in.dequeue();
  }

  action(m_decrementNumberOfMessages, "m", desc="Decrement the number of messages for which we're waiting") {
    peek(responseToCache_in, ResponseMsg) {
      cacheMemory[address].NumPendingMsgs := cacheMemory[address].NumPendingMsgs - in_msg.Acks;
    }
  }

  action(mm_decrementNumberOfMessages, "\m", desc="Decrement the number of messages for which we're waiting") {
    peek(forwardToCache_in, RequestMsg) {
      cacheMemory[address].NumPendingMsgs := cacheMemory[address].NumPendingMsgs - in_msg.Acks;
    }
  }

  action(n_popResponseQueue, "n", desc="Pop response queue") {
    responseToCache_in.dequeue();
  }

  action(o_checkForCompletion, "o", desc="Check if we have received all the messages required for completion") {
    if (cacheMemory[address].NumPendingMsgs == 0) {
      enqueue(triggerQueue_out, TriggerMsg, NULL_LATENCY) {
        out_msg.Address := address;
        out_msg.Type := TriggerType:ALL_ACKS;
      }
    }
  }

  action(q_sendDataFromCacheToCache, "q", desc="Send data from cache to cache") {
    peek(forwardToCache_in, RequestMsg) {
      enqueue(responseNetwork_out, ResponseMsg, CACHE_LATENCY) {
        out_msg.Address := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.Sender := id;
        out_msg.Destination.add(MachineType:L1Cache, in_msg.Requestor);
        out_msg.DataBlk := cacheMemory[address].DataBlk;
        out_msg.Acks := in_msg.Acks;
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }
  }
  
  action(u_writeDataToCache, "u", desc="Write data to cache") {
    peek(responseToCache_in, ResponseMsg) {
      cacheMemory[address].DataBlk := in_msg.DataBlk;
    }
  }

  action(v_writeDataToCacheVerify, "v", desc="Write data to cache, assert it was same as before") {
    peek(responseToCache_in, ResponseMsg) {
      assert(cacheMemory[address].DataBlk == in_msg.DataBlk);
      cacheMemory[address].DataBlk := in_msg.DataBlk;
    }
  }
  
  action(w_deallocateCacheBlock, "w", desc="Deallocate cache block.  Sets the cache to invalid, allowing a replacement in parallel with a fetch.") {
    if (cacheMemory.isTagPresent(address) == true) {
      cacheMemory.deallocate(address);
    }
  }
  
  action(x_allocateCacheBlock, "x", desc="Set cache tag equal to tag of block B.") {
    if (cacheMemory.isTagPresent(address) == false) {
      cacheMemory.allocate(address);
    }
  }

  action(zz_recycleMandatoryQueue, "\z", desc="Send the head of the mandatory queue to the back of the queue.") {
    mandatoryQueue_in.recycle();
  }

  //*****************************************************
  // TRANSITIONS
  //*****************************************************

  // Transitions for Load/Store/L2_Replacement from transient states
  transition({IM, SM, OM, IS, II}, {Store, L2_Replacement}) {
    zz_recycleMandatoryQueue;
  }

  transition({IM, IS, II}, {Load, Ifetch}) {
    zz_recycleMandatoryQueue;
  }

  // Transitions from Idle
  transition({NP, I}, Load, IS) {
    x_allocateCacheBlock;
    a_issueGETS;
    k_popMandatoryQueue;
  }

  transition({NP, I}, Ifetch, IS) {
    x_allocateCacheBlock;
    a_issueGETS;
    k_popMandatoryQueue;
  }

  transition({NP, I}, Store, IM) {
    x_allocateCacheBlock;
    b_issueGETX;
    k_popMandatoryQueue;
  }

  transition(I, L2_Replacement) {
    w_deallocateCacheBlock;
  }

  transition({NP, I}, Inv) {
    f_sendAck;
    l_popForwardQueue;
  }

  // Transitions from Shared
  transition({S, SM}, {Load, Ifetch}) {
    h_load_hit;
    k_popMandatoryQueue;
  }

  transition(S, Store, SM) {
    b_issueGETX;
    k_popMandatoryQueue;
  }

  transition(S, L2_Replacement, I) {
    w_deallocateCacheBlock;
  }

  transition(S, Inv, I) {
    f_sendAck;
    l_popForwardQueue;
  }

  // Transitions from Owned
  transition({O_C, O_D, OM}, {Load, Ifetch}) {
    h_load_hit;
    k_popMandatoryQueue;
  }

  transition({O_C, O_D}, Store, OM) {
    b_issueGETX;
    k_popMandatoryQueue;
  }

  transition(O_D, L2_Replacement, II) {
    dd_issueDirtyPUT;
  }

  transition(O_C, L2_Replacement, II) {
    d_issueCleanPUT;
  }

  transition({O_C, O_D}, Fwd_GETX, I) {
    e_sendData;
    l_popForwardQueue;
  }

  transition({O_C, O_D}, Fwd_GETS) {
    e_sendData;
    l_popForwardQueue;
  }

  // Transitions from MM
  transition(MM, {Load, Ifetch}) {
    h_load_hit;
    k_popMandatoryQueue;
  }

  transition(MM, Store) {
    hh_store_hit;
    k_popMandatoryQueue;
  }

  transition(MM, L2_Replacement, II) {
    dd_issueDirtyPUT;
  }

  transition(MM, Fwd_GETX, I) {
    e_sendData;
    l_popForwardQueue;
  }

  transition(MM, Fwd_GETS, I) {
    ee_sendDataExclusive;
    l_popForwardQueue;
  }
  
  // Transitions from M
  transition({E, M}, {Load, Ifetch}) {
    h_load_hit;
    k_popMandatoryQueue;
  }

  transition({E, M}, Store, MM) {
    hh_store_hit;
    k_popMandatoryQueue;
  }

  transition(E, L2_Replacement, II) {
    d_issueCleanPUT;
  }

  transition(M, L2_Replacement, II) {
    dd_issueDirtyPUT;
  }

  transition({E, M}, Fwd_GETX, I) {
    e_sendData;
    l_popForwardQueue;
  }

  transition(M, Fwd_GETS, O_D) {
    e_sendData;
    l_popForwardQueue;
  }

  transition(E, Fwd_GETS, O_C) {
    e_sendData;
    l_popForwardQueue;
  }

  // Transitions from IM

  transition(IM, Inv) {
    f_sendAck;
    l_popForwardQueue;
  }

  transition(IM, Ack) {
    m_decrementNumberOfMessages;
    o_checkForCompletion;
    n_popResponseQueue;
  }

  transition(IM, {Data, Exclusive_Data_Clean}, OM) {
    u_writeDataToCache;
    m_decrementNumberOfMessages; 
    o_checkForCompletion;
    n_popResponseQueue;
  }

  // Transitions from SM
  transition(SM, Inv, IM) {
    f_sendAck;
    l_popForwardQueue;
  }

  transition(SM, Ack) {
    m_decrementNumberOfMessages;
    o_checkForCompletion;
    n_popResponseQueue;
  }

  transition(SM, {Data, Exclusive_Data_Clean}, OM) {
    v_writeDataToCacheVerify;
    m_decrementNumberOfMessages; 
    o_checkForCompletion;
    n_popResponseQueue;
  }

  // Transitions from OM
  transition(OM, Own_GETX) {
    mm_decrementNumberOfMessages;
    o_checkForCompletion;
    l_popForwardQueue;
  }

  transition(OM, Fwd_GETX, IM) {
    e_sendData;
    l_popForwardQueue;
  }

  transition(OM, Fwd_GETS, OM) {
    e_sendData;
    l_popForwardQueue;
  }

  transition(OM, Ack) {
    m_decrementNumberOfMessages;
    o_checkForCompletion;
    n_popResponseQueue;
  }

  transition(OM, All_acks, MM) {
    hh_store_hit;
    gg_sendUnblockExclusive;
    j_popTriggerQueue;
  }

  // Transitions from IS

  transition(IS, Inv) {
    f_sendAck;
    l_popForwardQueue;
  }

  transition(IS, Data, S) {
    u_writeDataToCache;
    //    m_decrementNumberOfMessages;
    h_load_hit;
    g_sendUnblock;
    n_popResponseQueue;
  }

  transition(IS, Exclusive_Data_Clean, E) {
    u_writeDataToCache;
    //    m_decrementNumberOfMessages;
    h_load_hit;
    gg_sendUnblockExclusive;
    n_popResponseQueue;
  }

  transition(IS, Exclusive_Data_Dirty, M) {
    u_writeDataToCache;
    //    m_decrementNumberOfMessages;
    h_load_hit;
    gg_sendUnblockExclusive;
    n_popResponseQueue;
  }

  // Transitions from II

  transition(II, Writeback_Ack, I) {
    w_deallocateCacheBlock;
    n_popResponseQueue;
  }

  transition(II, {Fwd_GETX, Fwd_GETS}) {
    q_sendDataFromCacheToCache;
    l_popForwardQueue;
  }

  transition(II, Inv) {
    f_sendAck;
    l_popForwardQueue;
  }
}

